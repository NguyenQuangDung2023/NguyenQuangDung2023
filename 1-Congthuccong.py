
from manim import *
from pathlib import Path
import os 
from colour import *
import math
from manim.mobject.geometry.tips import ArrowTriangleTip,\
                                        ArrowSquareTip, ArrowSquareFilledTip,\
                                        ArrowCircleTip, ArrowCircleFilledTip
FLAGS = f"-pqk"#Thử nghiệm chất lượng video qua các Render
SCENE = "example" #  Sân khấu mình cần renderimport math as m
class SinAndCosFunctionPlot(MovingCameraScene):
    def construct(self):
        self.add_sound("backgroud-music")
        r =5
       # cirl = Circle(r).set_color(BLUE_A)
       # Lệnh vẽ cung tròn Arc: Arc(r,goc1,goc2,arc_center=tọa độ tâm)
        cirl = Arc(r, 0*DEGREES, 90*DEGREES,arc_center=ORIGIN,stroke_width=4)
        t =ValueTracker(0)
        s = ValueTracker(0)
        o = np.array([0,0,0])
        a = np.array([r*math.cos(45*DEGREES),0,0])
        b = np.array([r*math.cos(45*DEGREES),r*math.sin(45*DEGREES),0])
        m = np.array([0,1,0])
        n = np.array([1,0,0])
        Ox = np.array([5.5,0,0])
        Oy = np.array([0,5.5,0])
        Truchoanh=Line(o,Ox,color=RED,stroke_width=4)
        Tructung=Line(o,Oy,color=RED,stroke_width=4)
        Truchoanh.add_tip(tip_shape=StealthTip,tip_length=0.12,tip_width=3)
        Tructung.add_tip(tip_shape=StealthTip,tip_length=0.12,tip_width=3)
        OAB = VGroup()
        cos_beta = Brace(Line(a,o),DOWN).set_opacity(0.25)
        sin_beta = Brace(Line(a,b),RIGHT).set_opacity(0.25)
        cos_Label = Tex("$\\cos\\beta$").scale(0.65).move_to(np.array([0.5*r*math.cos(45*DEGREES),-0.75,0]))
        sin_Label = Tex("$\\sin\\beta$").scale(0.65).rotate(90*DEGREES,axis=OUT,about_point=ORIGIN).move_to(np.array([0.75+r*math.cos(45*DEGREES),0.5*r*math.sin(45*DEGREES),0]))
        OABB = Polygon(*[o,a,b],fill_opacity=0.35,color=TEAL,stroke_width=3)
        y = Tex("$\\beta$").scale(0.5).move_to(np.array([0.35,0.15,0]))
        OAB.add(OABB,cos_beta,cos_Label,sin_beta,sin_Label,y)
        oab = OAB.copy().rotate(30*DEGREES,axis=OUT,about_point=ORIGIN).set_color(TEAL).set_opacity(0.35)
        N = Dot().scale(0.5)
        M =Dot().scale(0.5)
        O = Dot(o).scale(0.5)
        y_M = Dot().scale(0.5)
        x_M =Dot().scale(0.5)
        x_N =Dot().scale(0.5)
        aa = np.array([r*math.cos((30+45)*DEGREES),r*math.cos((30+45)*DEGREES)*math.tan(30*DEGREES),0])
        bb = np.array([r*math.cos((30+45)*DEGREES),0,0])
        cc = np.array([r*math.cos((30+45)*DEGREES),r*math.cos(45*DEGREES)*math.sin(30*DEGREES),0])
        nn = np.array([r*math.cos(45*DEGREES)*math.cos(30*DEGREES),r*math.cos(45*DEGREES)*math.sin(30*DEGREES),0])
        mm = np.array([r*math.cos(45*DEGREES)*math.cos(30*DEGREES),0,0])
        NN = np.array([r*math.cos((30+45)*DEGREES),r*math.sin((30+45)*DEGREES),0])
        cos_ab = Brace(Line(o,bb),DOWN).set_color(PINK)
        ss_ab = Brace(Line(bb,mm),DOWN).set_color(YELLOW)
        sin_ab = Brace(Line(o,mm),DOWN,buff=0.75).set_color(BLUE)
        ss_ab_Label =Tex("$\\sin\\alpha\\cdot\\sin\\beta$").scale(0.5).move_to(np.array([0.5*r*math.cos((30+45)*DEGREES)+0.5*r*math.cos(45*DEGREES)*math.cos(30*DEGREES),-0.5,0]))
        cos_ab_Label =Tex("$\\cos(\\alpha+\\beta)$").scale(0.5).move_to(np.array([0.5*r*math.cos((30+45)*DEGREES),-0.5,0]))
        sin_ab_Label =Tex("$\\cos\\alpha\\cdot \\cos\\beta$").scale(0.5).move_to(np.array([0.5*r*math.cos(45*DEGREES)*math.cos(30*DEGREES),-1.1,0]))
        Nhom_chung_cos = VGroup(cos_ab,ss_ab,sin_ab,ss_ab_Label,cos_ab_Label,sin_ab_Label)
        abc = Polygon(*[o,aa,bb],fill_opacity=0.75,color=BLUE,stroke_width=3).round_corners(radius=0.01)
        omn = Polygon(*[o,m,n],fill_opacity=0.75,color=YELLOW,stroke_width=3).round_corners(radius=0.01)
        opq = Polygon(*[o,m,n],fill_opacity=0.75,color=TEAL,stroke_width=3).round_corners(radius=0.01)
        acN = Polygon(*[nn,aa,cc],fill_opacity=0.75,color=RED,stroke_width=3).round_corners(radius=0.01)
        ACN = Polygon(*[NN,nn,cc],fill_opacity=0.75,color=YELLOW,stroke_width=3).round_corners(radius=0.01)
        midd_AN = np.array([-0.75+r*math.cos((30+45)*DEGREES),0.5*r*math.sin((30+45)*DEGREES)+0.5*r*math.cos(45*DEGREES)*math.sin(30*DEGREES),0])
        Line_AN = Line(NN,cc)
        sin_cos = Brace(Line_AN,LEFT).set_color(ORANGE).set_opacity(0.5)
        Ten_sin = Tex("$\\sin\\beta\\cdot\\cos\\alpha$").move_to(midd_AN).scale(0.65).rotate(90*DEGREES).set_color(YELLOW)
        lline = Line(M.get_center(),M.get_center())
        llines = Line(M.get_center(),M.get_center())
        cos_sin = Brace(lline).set_color(ORANGE).set_opacity(0.5).set_opacity(0.5)
        Ten = Tex("a")
        x = Tex("$\\alpha$").scale(0.65).move_to(np.array([0.5,0.15,0]))
        Tex_N = Tex("$\\alpha$").scale(0.65).move_to(NN).shift(0.15*RIGHT+0.35*DOWN)
        #omn.add_updater(lambda z: z.become(Polygon(*[o,m,n],fill_opacity=0.35,color=YELLOW)))
        M.add_updater(lambda z: z.become(Dot(np.array([r*math.cos(45*DEGREES)*math.cos(t.get_value()*DEGREES),r*math.cos(45*DEGREES)*math.sin(t.get_value()*DEGREES),0])).scale(0.5)))
        N.add_updater(lambda z: z.become(Dot(np.array([r*math.cos((t.get_value()+45)*DEGREES),r*math.sin((t.get_value()+45)*DEGREES),0])).scale(0.5)))
        x_N.add_updater(lambda z: z.become(Dot(np.array([r*math.cos((t.get_value()+45)*DEGREES),0,0])).scale(0.5)))
        x_M.add_updater(lambda z: z.become(Dot(np.array([r*math.cos(45*DEGREES)*math.cos(t.get_value()*DEGREES),0,0])).scale(0.5)))
        y_M.add_updater(lambda z: z.become(Dot(np.array([0,r*math.cos(45*DEGREES)*math.sin(t.get_value()*DEGREES),0])).scale(0.5)))
        omn.add_updater(lambda z: z.become(Polygon(*[M.get_center(),o,x_M.get_center()],fill_opacity=0.35,color=YELLOW,stroke_width=3)))
        opq.add_updater(lambda z: z.become(Polygon(*[N.get_center(),o,x_N.get_center()],fill_opacity=0.2,color=PINK,stroke_width=3)))
        lline.add_updater(lambda z: z.become(Line(M.get_center(),x_M.get_center(),stroke_width=1).set_color(YELLOW)))
        llines.add_updater(lambda z: z.become(Line(M.get_center(),y_M.get_center(),stroke_width=1).set_color(YELLOW)))
        cos_sin .add_updater(lambda z: z.become(Brace(llines,RIGHT).set_stroke_brace(1)).set_opacity(0.5).set_color(YELLOW))
        Ten.add_updater(lambda z: z.become(Tex("$\\cos\\beta\\cdot\\sin\\alpha$").scale(0.45).rotate(90*DEGREES,axis=OUT,about_point=ORIGIN).next_to(np.array([0.5+r*math.cos(45*DEGREES)*math.cos(t.get_value()*DEGREES),0.5*r*math.cos(45*DEGREES)*math.sin(t.get_value()*DEGREES),0]),RIGHT)))
        Nhom_chung =VGroup(Ten,Ten_sin)
        sin_tong =Tex("$\\sin(\\alpha+\\beta)=\\sin\\alpha\\cos\\beta+\\sin\\beta\\cos\\alpha$").scale(0.65) .to_corner(UR).shift(3*RIGHT+1.75*UP)
        cos_tong =Tex("$\\cos(\\alpha+\\beta)=\\cos\\alpha\\cos\\beta-\\sin\\alpha\\sin\\beta$").scale(0.65) .to_corner(UR).shift(3*RIGHT)
        Cong_thuc =VGroup(sin_tong,cos_tong).arrange(direction=DOWN,aligned_edge=LEFT).to_corner(UR).shift(3*RIGHT+1.75*UP)
        #config.frame_width-1
        #config.frame_height-1
        #Chung = VGroup(cirl,omn,x_M,O,M).move_to(np.array([-3,-2,0]))
        self.add_sound("wind")
        self.play(self.camera.frame.animate.move_to(5*RIGHT+2.25*UP).set(width=12.8))#Trả Camera về chính giữa khung hình
        self.add_sound("wind")
        self.add(cirl,Tructung,Truchoanh)
        self.add(omn,x_M,O,M,opq,N,x_N,llines,cos_sin,Ten)#Buộc phải show các đối tượng trước các lệnh animations
        self.add_sound("wind")
        self.play(Rotate(OAB,30*DEGREES,axis=OUT,about_point=ORIGIN),t.animate.set_value(30),run_time=10)
        self.add_sound("wind")
        #self.play(t.animate.set_value(30),run_time=10)
        self.play(Create(oab))
        self.add_sound("wind")
        self.play(Write(x))
        self.play(Write(y))
        self.add_sound("wind")
        self.play(Rotate(abc.copy(),180*DEGREES,axis=OUT,about_point=aa))
        #self.remove(abc)
        self.add_sound("wind")
        self.play(Transform(abc.copy(),acN))
        self.add_sound("wind")
        self.play(Rotate(acN,90*DEGREES,axis=OUT,about_point=cc))
        self.remove(acN)
        self.add_sound("wind")
        self.play(Write(Tex_N))
        self.add_sound("wind")
        self.play(Transform(acN.copy().set_color(TEAL),ACN),run_time=6)
        self.add_sound("wind")
        self.play(Write(sin_cos))
        self.add_sound("wind")
        self.play(Write(Ten_sin))
        self.add_sound("wind")
        self.play(Flash(Ten_sin))
        self.add_sound("wind")
        self.play(Circumscribe(Ten_sin),run_time=5)
        self.add_sound("wind")
        self.play(Flash(Ten))
        self.add_sound("wind")
        self.play(Circumscribe(Ten),run_time=5)
        self.add_sound("soft-click")
        self.play(TransformMatchingTex(Nhom_chung.copy(),sin_tong),run_time=6)
        self.add_sound("wind")
        self.play(Circumscribe(sin_tong),run_time=5)
        self.wait(5)
        self.add_sound("wind")
        self.play(Write(Nhom_chung_cos),run_time=5)
        self.add_sound("wind")
        self.play(Flash(ss_ab_Label),Flash(cos_ab_Label),Flash(sin_ab_Label),run_time=5)
        self.add_sound("wind")
        self.play(Circumscribe(ss_ab_Label))
        self.add_sound("wind")
        self.play(Circumscribe(cos_ab_Label))
        self.add_sound("wind")
        self.play(Circumscribe(sin_ab_Label))
        self.add_sound("wind")
        Tenchung = VGroup(sin_ab_Label,cos_ab_Label,ss_ab_Label)
        self.play(Transform(Tenchung.copy(),cos_tong),run_time=6)
        self.add_sound("wind")
        self.play(Write(Cong_thuc))
        self.play(Circumscribe(Cong_thuc),run_time=5)
        self.add_sound("wind")
        self.play(Flash(Cong_thuc),run_time=2)
        self.wait(5)       
if __name__ == "__main__":
        script_name = f"{Path(__file__).resolve()}"
        os.system(f"manim {script_name} {SCENE} {FLAGS}")        